### A Pluto.jl notebook ###
# v0.12.4

using Markdown
using InteractiveUtils

# ╔═╡ 92928394-1462-11eb-04fd-557587660fc2
using Logging

# ╔═╡ 3cc48592-146d-11eb-1546-cd39a0f8e407
using SimJulia, ResumableFunctions

# ╔═╡ c395df98-145a-11eb-1716-2de187df1a1a
md"""
# Logging
The [Logging](https://docs.julialang.org/en/v1/stdlib/Logging/index.html) module will be used for efficient debugging and testing during development. 

A logger has its own lower level that it can show. In addition to this there is a global setting that determines the lowest level that will be registered.

Below you find some practical examples of logging
"""

# ╔═╡ dafa45ae-1462-11eb-3338-037167917f4d
disable_logging(LogLevel(-5001))

# ╔═╡ 0560f32a-1462-11eb-0685-09e4f341ddf5
"""
	logdemo1()

A small demo where everything is run on a single logger. Keep in mind when using the global logger, that its lowest level is `Debug` (`LogLevel(-1000)`), so you won't see anything below. 

Also keep in mind that you need to modify the global settings before you can see anything below `Debug`. You can do this with `disable_logging(LogLevel(N))`. 

### keywords
* logger: the logger you want to use. Defaults to the global logger.
"""
function logdemo1(args...; kwargs...)
	# direct all the following messages to my logger
	logger = get(kwargs, :logger, Logging.global_logger())
	with_logger(logger) do
		# print some information about the function
		@info "logdemo1 was invoked with:\n\t- args: $(args)\n\t- kwargs: $(kwargs)\n\t- using logger <$(logger)> (current logger's lowest level: $(Logging.min_enabled_level(logger)))"
		@debug "logdemo1 lowest level message that allows the debug level"
		@logmsg LogLevel(-2000) "not visible by default"
	end
end

# ╔═╡ 8ddac37c-1465-11eb-17d4-fdce80dc78fe
begin
	println("DEMO 1a - USING LOGGING DEFAULT SETTINGS\n$("-"^70)\n\n")
	logdemo1(1,2, goedemorgen="bonjour")
	println("-"^70)
end

# ╔═╡ b05f57c2-1466-11eb-272f-5fc93c04c744
begin 
	println("DEMO 1b - USING A SPECIFIC LOGGER THAT WILL SHOW THE LAST MESSAGE\n$("-"^70)\n\n")
	customlogger = Logging.SimpleLogger(stdout, LogLevel(-2000))
	logdemo1(3,4,logger=customlogger, goedenavond="bonsoir")
	println("-"^70)
end

# ╔═╡ 19b12fc6-1464-11eb-2fc1-cbb3f82479c5
begin
	"""
		logdemo2()

	A small demo where it is possible to direct the logs generated by a specific function to a file. The can be very handy for debugging purposes or analysis after a simulation. By default everything is run on a single logger. 

	### keywords
	* logger: the logger you want to use. Defaults to the global logger.
	* myspecialfunlogfilename: if you want to log `myspecialfun` to a file specify its name. When not specified the global logger is used 
	* myspecialfunlogfilemode: the mode you want to use to write to a file. Defaults to "w" (cf. [write modes](https://docs.julialang.org/en/v1/base/io-network/#Base.open))
	"""
	function logdemo2(args...; kwargs...)
		# direct all the following messages to my logger
		logger = get(kwargs, :logger, Logging.global_logger())
		with_logger(logger) do
			# log message from the 
			@info "logdemo2 was invoked with:\n\t- args: $(args)\n\t- kwargs: $(kwargs)\n\t- using logger <$(logger)> (current logger's lowest level: $(Logging.min_enabled_level(logger)))"
			# verify if a special logger should be used
			if haskey(kwargs, :myspecialfunlogfilename)
				logname = kwargs[:myspecialfunlogfilename]
				logmode = get(kwargs, :myspecialfunlogfilemode, "w")
				io = open(logname, logmode)
				speciallogger = SimpleLogger(io)
			else
				speciallogger = logger
			end
			
			# run the function with the appropriate logger
			with_logger(speciallogger) do
				for i in 1:get(kwargs,:maxrep, 20)
					myspecialfun(i; speciallogger=speciallogger)
				end
			end
			
			# close io if required
			if haskey(kwargs, :myspecialfunlogfilename)
				close(io)
			end
		end
	end

	"""
		myspecialfun(args...; kwargs...)
	
	a function that generates log messages
	
	### keywords
	"""
	function myspecialfun(args...; kwargs...)
		@info "myspecialfun was invoked with:\n\t- args: $(args)\n\t- kwargs: $(kwargs)\n\t- using logger <$(kwargs[:speciallogger])> "
	end
end

# ╔═╡ e3eae0ce-1462-11eb-2e02-fd2f746569d1
begin
	println("DEMO 2a - USING LOGGING DEFAULT SETTINGS\n$("-"^70)\n\n")
	logdemo2(1,2, goedemorgen="bonjour")
	println("-"^70)
end

# ╔═╡ 12710aa4-146b-11eb-034a-97b515563abc
begin
	println("DEMO 2b - USING LOGGING TO FILE SETTINGS\n$("-"^70)\n\n")
	logdemo2(1,2, myspecialfunlogfilename="demo2.log", maxrep=10)
	println("-"^70)
end

# ╔═╡ 0368ea70-145b-11eb-0b5c-fb3a33bf2027
md"""
# SimJulia
Before starting a larger project, we will look into some SimJulia tricks
"""

# ╔═╡ dd63ff16-146d-11eb-059c-0586e1f972a5
md"""
## Working with resumable functions
Using a resumable function, try to implement:
1. the pascal triangle: each iteration should return a line of the Pascal triangle.
2. a root finding method (e.g. square root of a number)

*Note*: a resumable function returns an iterator you need to call.
"""

# ╔═╡ ed555bfc-146d-11eb-2b52-bbec67faaf0f


# ╔═╡ 118eecdc-146d-11eb-1d4b-71b301d4d5e6
md"""
## Process dependencies
Below you have an illustration of a process waiting for another one to terminate before continuing.
"""

# ╔═╡ 363592fc-146d-11eb-2dde-d56c18095702
let
	@resumable function basic(sim::Simulation)
    	@info "Basic goes to work on time $(now(sim))"
    	p = @process bottleneck(sim)
    	@yield p
    	@info "Basic continues after bottleneck completion on time $(now(sim))"
	end

	@resumable function bottleneck(sim::Simulation)
   		@yield timeout(sim, 10)
	end
	
	@info "\n$("-"^70)\nProcess dependencies\n$("-"^70)\n"
	sim = Simulation()
	@process basic(sim)
	run(sim)
end

# ╔═╡ 9da38750-146d-11eb-0757-2318eb6520ca
md"""
## Working with containers
Containers represent a level of something (e.g. liquid level, energy ...). If you want to store a specific type of object, you will be better of using a `store`.

Experiment a bit with containers (::Container). Discover their attributes (environment, capacity, level, get\_queue, put\_queue, seid) and find out how to use them. Generate a simple setting with:
1. a fill process that waits for a random time $t < 10 \in \mathbb{N}$ and then adds 1 unit to a container. This process repeats forever.
2. an empty process that waits for a random time $t < 10 \in \mathbb{N}$ and then requires a random amount from the container. This process repeats forever.
3. a monitor proces that periodically prints an info message detailing the current level of the container. This process repeats forever.
"""

# ╔═╡ 73f24a8e-146f-11eb-2978-cfef033adae1
let
	@resumable function fill(sim::Simulation, c::Container)
		while true 
			@yield timeout(sim,rand(1:10))
			@yield put(c,1)
			@info "item added to the container on time $(now(sim))"
		end
	end

	@resumable function empty(sim::Simulation, c::Container)
		while true
			@yield timeout(sim,rand(1:10))
			n = rand(1:3)
			@info "Filed my request for $(n) items on time $(now(sim))"
			@yield get(c,n)
			@info "Got my $(n) items on time $(now(sim))"
		end
	end

	@resumable function monitor(sim::Simulation, c::Container)
		while true
			@info "$(now(sim)) - current container level: $(c.level)/$(c.capacity)"
			@yield timeout(sim,1)
		end
	end
	
	# setup the simulation
	@info "\n$("-"^70)\nWorking with containers\n$("-"^70)\n"
	sim = Simulation()
	c = Container(sim,10)
	@process fill(sim,c)
	@process monitor(sim,c)
	@process empty(sim,c)
	run(sim,30)
end

# ╔═╡ 4bf1fce0-1470-11eb-1290-63d06c8246a2
md"""
#### Excercise: application with statistics 
Consider a candy machines that is continuously being monitored by a supervisor.  If the level is below a given treshold, the supervisor fills the machine up. 
* Client arrival follows an exponential distribution with parameter $\theta = 1$ and each client takes two candies at a time.
* Look at the mean time between refills. Is this what you would expect?
* What happens when the amount of candy varies?  Is this still what you would expect? E.g. a clients takes one, two or three candies.
"""

# ╔═╡ 595d99f0-1470-11eb-20d0-87143910a5e6


# ╔═╡ 71911828-1470-11eb-3519-bb52522ed2c9
md"""
## Working with `Stores`
A store can hold objects (struct) that can be used by other processes. Let's reconsider the same small scale application we did with the containers, i.e. generate a simple setting and verify everything works as intended (e.g. a fill, empty and monitor process). 
"""

# ╔═╡ fbfed3c4-1470-11eb-0f28-231b891d0d9b
let
	# our own type of object
	struct Object
		id::Int
	end

	@resumable function fill(sim::Simulation, s::Store)
		i = 0
		while true 
			i += 1
			item = Object(i)
			@yield timeout(sim,rand(1:10))
			@yield put(s,item)
			@info "item $(item) added to the store on time $(now(sim))"
		end
	end
	
	@resumable function empty(sim::Simulation, s::Store)
		while true
			@yield timeout(sim,rand(1:10))
			n = rand(1:3)
			@info "Filed my request for $(n) items on time $(now(sim))"
			for _ in 1:n
				@yield get(s)
			end
			@info "Got my $(n) items on time $(now(sim))"
		end
	end
	
	@resumable function monitor(sim::Simulation, s::Store)
		while true
			@info "$(now(sim)) - current store level: $(length(s.items))/$(s.capacity)"
			@yield timeout(sim,1)
		end
	end
	
	# setup the simulation
	@info "\n$("-"^70)\nWorking with stores\n$("-"^70)\n"
	sim = Simulation()
	s = Store{Object}(sim, capacity=UInt(10))
	
	@process fill(sim, s)
	@process empty(sim, s)
	@process monitor(sim, s)
	run(sim,30)
	
end

# ╔═╡ 414b4ee2-1473-11eb-3d7b-ef4f49e7efa0


# ╔═╡ Cell order:
# ╟─c395df98-145a-11eb-1716-2de187df1a1a
# ╠═92928394-1462-11eb-04fd-557587660fc2
# ╠═dafa45ae-1462-11eb-3338-037167917f4d
# ╠═0560f32a-1462-11eb-0685-09e4f341ddf5
# ╠═8ddac37c-1465-11eb-17d4-fdce80dc78fe
# ╠═b05f57c2-1466-11eb-272f-5fc93c04c744
# ╠═19b12fc6-1464-11eb-2fc1-cbb3f82479c5
# ╠═e3eae0ce-1462-11eb-2e02-fd2f746569d1
# ╠═12710aa4-146b-11eb-034a-97b515563abc
# ╟─0368ea70-145b-11eb-0b5c-fb3a33bf2027
# ╠═3cc48592-146d-11eb-1546-cd39a0f8e407
# ╟─dd63ff16-146d-11eb-059c-0586e1f972a5
# ╠═ed555bfc-146d-11eb-2b52-bbec67faaf0f
# ╟─118eecdc-146d-11eb-1d4b-71b301d4d5e6
# ╠═363592fc-146d-11eb-2dde-d56c18095702
# ╟─9da38750-146d-11eb-0757-2318eb6520ca
# ╠═73f24a8e-146f-11eb-2978-cfef033adae1
# ╟─4bf1fce0-1470-11eb-1290-63d06c8246a2
# ╠═595d99f0-1470-11eb-20d0-87143910a5e6
# ╟─71911828-1470-11eb-3519-bb52522ed2c9
# ╠═fbfed3c4-1470-11eb-0f28-231b891d0d9b
# ╠═414b4ee2-1473-11eb-3d7b-ef4f49e7efa0
